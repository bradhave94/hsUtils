---
export const prerender = false;
import Layout from "../layouts/Layout.astro";
import SlugModal from "../components/SlugModal.astro";
import { getBlogPosts, getBlogInfo, getBlogTags } from "../lib/api/hubspot";
import { checkAuth } from "../lib/middleware/auth";
import cache, { CacheType } from "../lib/utils/cache";
import type { HubSpotBlogPost, BlogTag } from "@/types/hubspot";
import { formatDate } from "../lib/utils/date";

let posts: HubSpotBlogPost[] = [];
let blogInfo: Array<{ url: string; template_path: string }> = [];
let error = "";

const { accessToken, refreshToken, isAuthenticated } = await checkAuth(
    Astro.cookies,
);
const cacheDisabled = Astro.cookies.get("cache-disabled")?.boolean() || false;

if (!isAuthenticated) {
    return Astro.redirect("/?error=missing_credentials");
}

const isArchived = Astro.url.searchParams.has("archived");

try {
    // Only use cache if not disabled
    if (!cacheDisabled) {
        posts =
            cache.get(CacheType.BLOGS, accessToken as string, {
                archived: isArchived,
            }) || [];
        blogInfo = cache.get(CacheType.BLOG_INFO, accessToken as string) || [];
    }

    // If not in cache or cache is disabled, fetch from API
    if (posts.length === 0) {
        posts = await getBlogPosts(
            accessToken as string,
            isArchived,
            refreshToken,
        );
        if (!cacheDisabled) {
            cache.set(CacheType.BLOGS, accessToken as string, posts, {
                archived: isArchived,
            });
        }
    }

    if (blogInfo.length === 0) {
        blogInfo = await getBlogInfo(accessToken as string, refreshToken);
        if (!cacheDisabled) {
            cache.set(CacheType.BLOG_INFO, accessToken as string, blogInfo);
        }
    }
} catch (err) {
    console.error("Error fetching pages:", err);
    error = `Failed to fetch pages: ${err instanceof Error ? err.message : "Unknown error"}`;
}

// Fetch tags for the blog posts
const tags = (await getBlogTags(accessToken as string)) as BlogTag[];
const portalId = Astro.cookies.get("hubspot_portal_id")?.value;

function getStatusLabel(post: HubSpotBlogPost): string {
    if (
        post.archivedAt &&
        typeof post.archivedAt === "number" &&
        post.archivedAt !== 0
    )
        return "Archived";
    switch (post.state || "DRAFT") {
        case "PUBLISHED":
            return "Published";
        case "DRAFT":
            return "Draft";
        case "SCHEDULED":
            return "Scheduled";
        case "PUBLISHED_OR_SCHEDULED":
            return "Published";
        default:
            return post.state || "Draft";
    }
}

function getStatusClass(status: string): string {
    switch (status.toLowerCase()) {
        case "published":
            return "text-green-500";
        case "draft":
            return "text-yellow-500";
        case "archived":
            return "text-red-500";
        case "scheduled":
            return "text-blue-500";
        default:
            return "text-gray-500";
    }
}

// Add these type declarations
interface BlogPost extends HubSpotBlogPost {
    tagIds?: string[];
}

interface BlogInfo {
    url: string;
    template_path: string;
}

// Group posts by blog
const groupedPosts = blogInfo.reduce<Record<string, BlogPost[]>>(
    (acc, blog) => {
        // Get posts for this blog
        const blogPosts = posts.filter((post) => post.url?.includes(blog.url));

        // Sort posts: Published first, then Draft, then Archived
        blogPosts.sort((a, b) => {
            const getStatusOrder = (post: BlogPost) => {
                if (
                    post.archivedAt &&
                    typeof post.archivedAt === "number" &&
                    post.archivedAt !== 0
                )
                    return 2; // Archived last
                if (post.state === "DRAFT") return 1; // Draft second
                return 0; // Published first
            };

            const aOrder = getStatusOrder(a);
            const bOrder = getStatusOrder(b);

            // First sort by status
            if (aOrder !== bOrder) {
                return aOrder - bOrder;
            }

            // Then by name
            return (a.name || "").localeCompare(b.name || "");
        });

        acc[blog.url] = blogPosts;
        return acc;
    },
    {},
);

// Add "No Blog" group for posts that don't match any blog
const noBlogPosts = posts.filter(
    (post) => !blogInfo.some((blog) => post.url?.includes(blog.url)),
);

// Sort "No Blog" posts the same way
noBlogPosts.sort((a, b) => {
    const getStatusOrder = (post: BlogPost) => {
        if (
            post.archivedAt &&
            typeof post.archivedAt === "number" &&
            post.archivedAt !== 0
        )
            return 2;
        if (post.state === "DRAFT") return 1;
        return 0;
    };

    const aOrder = getStatusOrder(a);
    const bOrder = getStatusOrder(b);

    if (aOrder !== bOrder) {
        return aOrder - bOrder;
    }

    return (a.name || "").localeCompare(b.name || "");
});

groupedPosts["No Blog"] = noBlogPosts;

// Create a Map for tags lookup
const tagsMap = new Map(tags.map((tag) => [tag.id.toString(), tag]));
---

<Layout title="HubSpot Site Pages">
    <meta name="access-token" content={accessToken} />
    <main class="container mx-auto max-w-4xl px-4 py-8">
        <h1 class="text-4xl font-bold mb-4 text-blue-200">
            HubSpot Blog Posts <span class="text-xl text-blue-500"
                >({posts.length} posts)</span>
        </h1>

        {
            Astro.url.searchParams.has("archived") ? (
                <a
                    href="/blog-posts"
                    class="text-blue-400 hover:text-blue-300 mb-8 block"
                >
                    Hide archived posts
                </a>
            ) : (
                <a
                    href="/blog-posts?archived=true"
                    class="text-blue-400 hover:text-blue-300 mb-8 block"
                >
                    Show archived posts
                </a>
            )
        }

        {
            error && (
                <p class="text-red-500 mb-6 p-4 bg-red-100 rounded-lg">
                    {error}
                </p>
            )
        }

        {
            posts.length === 0 ? (
                <p class="text-gray-400 text-xl">
                    No pages found.{" "}
                    {error ? "An error occurred while fetching posts." : ""}
                </p>
            ) : (
                <div class="page-tree-container">
                    <div class="flex space-x-4 mb-4">
                        <button
                            id="changeSelectedSlugsBtn"
                            class="changeSelectedSlugsBtn bg-yellow-600 hover:bg-yellow-700 text-white py-2 px-4 rounded transition duration-300 disabled:opacity-50 disabled:cursor-not-allowed"
                            disabled
                        >
                            Change Selected Slugs
                        </button>
                        <button
                            id="changeSelectedTagsBtn"
                            class="changeSelectedTagsBtn bg-purple-600 hover:bg-purple-700 text-white py-2 px-4 rounded transition duration-300 disabled:opacity-50 disabled:cursor-not-allowed"
                            disabled
                        >
                            Edit Selected Tags
                        </button>
                    </div>

                    <ul class="space-y-3">
                        {Object.entries(groupedPosts).map(
                            ([blogUrl, posts]) =>
                                posts.length > 0 && (
                                    <li class="blog-group">
                                        <details class="bg-gray-800 rounded-lg p-4 open">
                                            <summary class="flex items-center justify-between cursor-pointer">
                                                <div class="flex items-center">
                                                    <input
                                                        type="checkbox"
                                                        class="blog-checkbox custom-checkbox mr-2"
                                                        data-blog-url={blogUrl}
                                                    />
                                                    <span class="text-xl font-semibold text-white">
                                                        {blogUrl}
                                                    </span>
                                                    <span class="ml-2 text-sm text-blue-400">
                                                        ({posts.length} posts)
                                                    </span>
                                                </div>
                                            </summary>
                                            <ul class="mt-4 space-y-4">
                                                {posts.map((post) => {
                                                    const status =
                                                        getStatusLabel(post);
                                                    return (
                                                        <li class="post bg-gray-700 rounded-lg p-4">
                                                            <div class="flex items-center justify-between">
                                                                <div class="flex-grow">
                                                                    <div class="flex items-center">
                                                                        <label class="flex items-center cursor-pointer">
                                                                            <input
                                                                                type="checkbox"
                                                                                class="post-checkbox custom-checkbox mr-2 aspect-square"
                                                                                data-post-id={
                                                                                    post.id
                                                                                }
                                                                                data-template-path={
                                                                                    post.templatePath
                                                                                }
                                                                                data-current-url={
                                                                                    post.url
                                                                                }
                                                                            />
                                                                            <h3 class="text-2xl font-semibold text-blue-400 leading-none">
                                                                                {
                                                                                    post.name
                                                                                }
                                                                            </h3>
                                                                        </label>
                                                                    </div>
                                                                    <div class="mt-2 text-sm flex flex-col gap-2 text-gray-300">
                                                                        <p>
                                                                            URL:{" "}
                                                                            {
                                                                                post.url
                                                                            }
                                                                        </p>
                                                                        <div class="flex flex-wrap gap-2 mt-1">
                                                                            <span class="text-gray-400">
                                                                                Tags:
                                                                            </span>
                                                                            {post
                                                                                .tagIds
                                                                                ?.length ? (
                                                                                post.tagIds.map(
                                                                                    (
                                                                                        id,
                                                                                    ) => {
                                                                                        const tag =
                                                                                            tagsMap.get(
                                                                                                id.toString(),
                                                                                            );
                                                                                        return (
                                                                                            <span class="px-2 py-1 text-xs bg-gray-600 rounded-full">
                                                                                                {tag?.name ||
                                                                                                    id}
                                                                                            </span>
                                                                                        );
                                                                                    },
                                                                                )
                                                                            ) : (
                                                                                <span class="text-gray-500">
                                                                                    None
                                                                                </span>
                                                                            )}
                                                                        </div>
                                                                        <p>
                                                                            Status:{" "}
                                                                            <span
                                                                                class={getStatusClass(
                                                                                    status,
                                                                                )}
                                                                            >
                                                                                {
                                                                                    status
                                                                                }
                                                                            </span>
                                                                        </p>

                                                                        {post.archivedAt ? (
                                                                            <p>
                                                                                Archived:{" "}
                                                                                {formatDate(post.archivedAt.toString())}
                                                                            </p>
                                                                        ) : null}
                                                                    </div>
                                                                </div>
                                                                <div class="flex flex-col space-y-2 min-w-[150px] ml-12 text-right justify-end">
                                                                    <button
                                                                        class="change-slug-btn text-right text-sm text-blue-400 hover:text-blue-300"
                                                                        data-page-id={
                                                                            post.id
                                                                        }
                                                                        data-current-url={
                                                                            post.url
                                                                        }
                                                                    >
                                                                        Change
                                                                        Slug
                                                                    </button>
                                                                    <button
                                                                        class="edit-tags-btn text-right text-sm text-blue-400 hover:text-blue-300"
                                                                        data-post-id={
                                                                            post.id
                                                                        }
                                                                        data-post-tags={post.tagIds?.join(
                                                                            ",",
                                                                        )}
                                                                    >
                                                                        Edit
                                                                        Tags
                                                                    </button>
                                                                    <a
                                                                        href={
                                                                            post.url
                                                                        }
                                                                        target="_blank"
                                                                        rel="noopener noreferrer"
                                                                        class="view-live-post-btn text-right text-sm text-blue-400 hover:text-blue-300"
                                                                    >
                                                                        View
                                                                        Live
                                                                        Post
                                                                    </a>
                                                                    <a
                                                                        href={`https://app.hubspot.com/blog/${portalId}/editor/${post.id}/content`}
                                                                        target="_blank"
                                                                        rel="noopener noreferrer"
                                                                        class="edit-in-hubspot-btn text-right text-sm text-blue-400 hover:text-blue-300"
                                                                    >
                                                                        Edit in
                                                                        HubSpot
                                                                    </a>
                                                                    {post.archivedAt ? (
                                                                            <button
                                                                                class="restore-page-btn text-right text-sm text-blue-400 hover:text-blue-300"
                                                                                data-page-id={
                                                                                    post.id
                                                                                }
                                                                            >
                                                                                Restore
                                                                                Post
                                                                            </button>
                                                                        ) : null }
                                                                </div>
                                                            </div>
                                                        </li>
                                                    );
                                                })}
                                            </ul>
                                        </details>
                                    </li>
                                ),
                        )}
                    </ul>
                </div>
            )
        }

        <a
            href="/"
            class="inline-block mt-8 bg-orange-500 hover:bg-orange-600 text-white font-bold py-2 px-4 rounded transition duration-300"
            >Back to Home</a
        >
    </main>

    <SlugModal />

    <dialog
        id="bulkTagsModal"
        class="bg-gray-800 p-6 rounded-lg shadow-xl text-white w-[600px]"
    >
        <div class="flex justify-between items-center mb-4">
            <h3 class="text-xl font-bold">Edit Tags for Selected Posts</h3>
            <button class="close-modal-btn text-gray-400 hover:text-white"
                >&times;</button
            >
        </div>
        <div class="space-y-4">
            <div class="flex space-x-4 mb-4">
                <button
                    id="addTagsBtn"
                    class="bg-green-600 hover:bg-green-700 px-4 py-2 rounded active"
                    >Add Tags</button
                >
                <button
                    id="removeTagsBtn"
                    class="bg-red-600 hover:bg-red-700 px-4 py-2 rounded"
                    >Remove Tags</button
                >
            </div>
            <div id="newBulkTagSection" class="mb-4 space-y-2">
                <div class="flex space-x-2">
                    <input
                        type="text"
                        id="newBulkTagInput"
                        placeholder="New tag name"
                        class="flex-1 p-2 bg-gray-700 rounded text-white"
                    />
                    <button
                        id="addNewBulkTagBtn"
                        class="bg-green-600 hover:bg-green-700 px-4 py-2 rounded"
                    >
                        Add New Tag
                    </button>
                </div>
                <div id="newBulkTagError" class="text-red-500 text-sm hidden">
                </div>
            </div>
            <div
                class="max-h-[400px] overflow-y-auto space-y-2"
                id="bulkTagsContainer"
            >
                <!-- Tags will be populated here -->
            </div>
            <div class="flex justify-end space-x-3 mt-4">
                <button
                    class="close-modal-btn bg-gray-600 hover:bg-gray-700 px-4 py-2 rounded"
                    >Cancel</button
                >
                <button
                    id="saveBulkTagsBtn"
                    class="bg-green-600 hover:bg-green-700 px-4 py-2 rounded"
                    >Apply Changes</button
                >
            </div>
        </div>
    </dialog>

    <dialog
        id="tagsModal"
        class="bg-gray-800 p-6 rounded-lg shadow-xl text-white w-[500px]"
    >
        <div class="flex justify-between items-center mb-4">
            <h3 class="text-xl font-bold">Edit Tags</h3>
            <button class="close-modal-btn text-gray-400 hover:text-white"
                >&times;</button
            >
        </div>
        <div class="space-y-4">
            <div class="mb-4 space-y-2">
                <div class="flex space-x-2">
                    <input
                        type="text"
                        id="newTagInput"
                        placeholder="New tag name"
                        class="flex-1 p-2 bg-gray-700 rounded text-white"
                    />
                    <button
                        id="addNewTagBtn"
                        class="bg-green-600 hover:bg-green-700 px-4 py-2 rounded"
                    >
                        Add New Tag
                    </button>
                </div>
                <div id="newTagError" class="text-red-500 text-sm hidden"></div>
            </div>
            <div
                class="max-h-[400px] overflow-y-auto space-y-2"
                id="tagsContainer"
            >
                <!-- Tags will be populated here -->
            </div>
            <div class="flex justify-end space-x-3 mt-4">
                <button
                    class="close-modal-btn bg-gray-600 hover:bg-gray-700 px-4 py-2 rounded"
                    >Cancel</button
                >
                <button
                    id="saveTagsBtn"
                    class="bg-green-600 hover:bg-green-700 px-4 py-2 rounded"
                    >Save Changes</button
                >
            </div>
        </div>
    </dialog>

    <blog-info data-info={JSON.stringify(blogInfo)}></blog-info>
    <tags-info data-info={JSON.stringify(tags)}></tags-info>
    <pages-data data-pages={JSON.stringify(posts)}></pages-data>
</Layout>

<style>
    .custom-checkbox {
        appearance: none;
        -webkit-appearance: none;
        width: 1.5rem;
        height: 1.5rem;
        border: 2px solid #4a5568;
        border-radius: 0.25rem;
        background-color: #2d3748;
        display: inline-flex;
        align-items: center;
        justify-content: center;
        cursor: pointer;
        margin-right: 0.5rem;
        transition: all 0.2s ease-in-out;
    }

    .custom-checkbox:checked {
        @apply bg-blue-600 border-blue-400;
    }

    .custom-checkbox:checked::after {
        content: "\2714";
        color: white;
        font-size: 14px;
        font-weight: bold;
    }

    .custom-checkbox:focus {
        outline: none;
        box-shadow: 0 0 0 3px rgba(66, 153, 225, 0.5);
    }

    .custom-checkbox:hover {
        border-color: #4299e1;
    }

    .active {
        @apply ring-2 ring-white;
    }
</style>

<script>
    import type { HubSpotBlogPost } from '../types/hubspot';
    import { CacheType } from '../lib/utils/cache';

    document.addEventListener('DOMContentLoaded', () => {
        const pagesData = document.querySelector('pages-data')?.dataset.pages;
        const pages: HubSpotBlogPost[] = pagesData ? JSON.parse(pagesData) : [];
        const blogInfo = JSON.parse(
            document.querySelector("blog-info")?.dataset.info,
        );
        const tags = JSON.parse(
            document.querySelector("tags-info")?.dataset.info,
        );

        // Create tagsMap in the client-side code
        const tagsMap = new Map(tags.map((tag) => [tag.id.toString(), tag]));

        const blogCheckboxes = document.querySelectorAll(".blog-checkbox");
        const postCheckboxes = document.querySelectorAll(".post-checkbox");
        const changeSelectedSlugsBtn = document.getElementById(
            "changeSelectedSlugsBtn",
        );
        const changeSelectedTagsBtn = document.getElementById(
            "changeSelectedTagsBtn",
        );

        // Handle blog checkbox changes
        blogCheckboxes.forEach((checkbox) => {
            checkbox.addEventListener("change", (e) => {
                const blogDetails = e.target.closest("details");
                const postCheckboxes =
                    blogDetails?.querySelectorAll(".post-checkbox");
                const isChecked = e.target.checked;

                postCheckboxes?.forEach((cb) => {
                    cb.checked = isChecked;
                });

                updateChangeSelectedButtons();
            });
        });

        // Handle post checkbox changes
        postCheckboxes.forEach((checkbox) => {
            checkbox.addEventListener("change", (e) => {
                const blogDetails = e.target.closest("details");
                const blogCheckbox =
                    blogDetails?.querySelector(".blog-checkbox");
                const postCheckboxes =
                    blogDetails?.querySelectorAll(".post-checkbox");

                if (postCheckboxes) {
                    const allChecked = Array.from(postCheckboxes).every(
                        (cb) => cb.checked,
                    );
                    const someChecked = Array.from(postCheckboxes).some(
                        (cb) => cb.checked,
                    );

                    if (blogCheckbox) {
                        blogCheckbox.checked = allChecked;
                        blogCheckbox.indeterminate = someChecked && !allChecked;
                    }
                }

                updateChangeSelectedButtons();
            });
        });

        function updateButtonStates() {
            const anyChecked = Array.from(postCheckboxes).some(
                (checkbox) => checkbox.checked,
            );
            if (changeSelectedSlugsBtn)
                changeSelectedSlugsBtn.disabled = !anyChecked;
        }

        async function handleSlugChange(
            pages: Array<{ pageId: string; currentUrl: string }>,
            pattern: string,
        ) {
            try {
                const patternMatch = pattern.match(/#(.+?)#(.*)/);
                if (!patternMatch) {
                    throw new Error(
                        "Invalid pattern format. Pattern should be in format: #regex#replacement",
                    );
                }

                const [, regexPattern, replacement] = patternMatch;

                try {
                    new RegExp(regexPattern);
                } catch (e) {
                    throw new Error("Invalid regular expression pattern");
                }

                const regex = new RegExp(regexPattern);
                const updates = pages.map((page) => {
                    if (!page.currentUrl) {
                        throw new Error(`Missing URL for page ${page.pageId}`);
                    }

                    try {
                        const url = new URL(page.currentUrl);
                        const currentPath = url.pathname;

                        // Find matching blog
                        const matchingBlog = blogInfo.find(blog => {
                            const blogUrl = new URL(blog.url);
                            return currentPath.startsWith(blogUrl.pathname);
                        });

                        if (!matchingBlog) {
                            throw new Error(`No matching blog found for URL: ${currentPath}`);
                        }

                        // Get blog path and clean it
                        const blogUrl = new URL(matchingBlog.url);
                        const blogPath = blogUrl.pathname.replace(/\/$/, '');

                        // Remove blog path from current path to get the actual slug
                        const basePath = currentPath.replace(blogPath, '');

                        // Apply the pattern to get new slug
                        let newSlug = basePath.replace(regex, replacement)
                            .replace(/\/+/g, '/') // Remove multiple slashes
                            .replace(/\/$/, '')   // Remove trailing slash
                            .replace(/^(?!\/)/, '/'); // Ensure starts with slash

                        return {
                            pageId: page.pageId,
                            newSlug // Don't add blog path back, HubSpot will handle this
                        };
                    } catch (e) {
                        throw new Error(
                            `Invalid URL format for page ${page.pageId}: ${page.currentUrl} - ${e.message}`,
                        );
                    }
                });

                for (const update of updates) {
                    const response = await fetch(
                        "/api/blog-posts/update-slug",
                        {
                            method: "POST",
                            headers: { "Content-Type": "application/json" },
                            body: JSON.stringify(update),
                        },
                    );

                    if (!response.ok) {
                        const errorData = await response
                            .json()
                            .catch(() => ({}));
                        throw new Error(
                            `Failed to update slug for page ${update.pageId}: ${errorData.message || response.statusText}`,
                        );
                    }

                    // Get pages data from DOM
                    const pagesData = document.querySelector('pages-data')?.dataset.pages;
                    const pages: HubSpotBlogPost[] = pagesData ? JSON.parse(pagesData) : [];

                    // Find the original page data
                    const originalPage = pages.find(p => p.id === update.pageId);
                    if (!originalPage) {
                        throw new Error(`Could not find page with ID ${update.pageId}`);
                    }

                    // Find matching blog for this post
                    const matchingBlog = blogInfo.find(blog => {
                        const blogUrl = new URL(blog.url);
                        return originalPage.url?.includes(blogUrl.pathname);
                    });

                    if (!matchingBlog) {
                        throw new Error(`No matching blog found for post ${update.pageId}`);
                    }

                    // Parse the original URL and blog URL
                    const url = new URL(originalPage.url);
                    const blogUrl = new URL(matchingBlog.url);

                    // Get the post-specific part of the path by removing the blog path
                    const postPath = url.pathname.replace(blogUrl.pathname, '');

                    // Apply the regex replacement only to the post path
                    const newPostPath = postPath.replace(regex, replacement)
                        .replace(/\/+/g, '/') // Remove multiple slashes
                        .replace(/\/$/, '') // Remove trailing slash
                        .replace(/^\//, ''); // Remove leading slash for post path

                    // Construct the full URL by combining blog path with new post path
                    // Make sure blog path ends with slash and post path doesn't start with slash
                    const blogPath = blogUrl.pathname.endsWith('/') ? blogUrl.pathname : `${blogUrl.pathname}/`;
                    const newUrl = `${url.protocol}//${url.host}${blogPath}${newPostPath}`;

                    // Update cache for this specific page
                    await updatePagesInCache([update.pageId], { url: newUrl });
                }

                location.reload();
            } catch (error) {
                console.error("Error updating slugs:", error);
                alert(
                    "Failed to update slugs: " +
                        (error instanceof Error
                            ? error.message
                            : "Unknown error"),
                );
            }
        }

        async function handleRestorePage(pageId: string) {
            try {
                const response = await fetch("/api/blog-posts/restore", {
                    method: "POST",
                    headers: { "Content-Type": "application/json" },
                    body: JSON.stringify({ pageId })
                });

                if (!response.ok) throw new Error("Failed to restore page");

                await updatePagesInCache([pageId], { archivedAt: 0 });
                location.reload();
            } catch (error) {
                console.error("Error restoring page:", error);
                alert(
                    "Failed to restore page: " +
                        (error instanceof Error
                            ? error.message
                            : "Unknown error"),
                );
            }
        }

        changeSelectedSlugsBtn?.addEventListener("click", async () => {
            const selectedPosts = Array.from(
                    document.querySelectorAll(".post-checkbox:checked"),
                ).map((cb) => ({
                    pageId: cb.dataset.postId,
                    currentUrl: cb.dataset.currentUrl,
                }));

            if (window.openSlugModal && selectedPosts.length > 0) {
                console.log('Opening slug modal');
                const pattern = await window.openSlugModal(selectedPosts, blogInfo);
                if (pattern) {
                    await handleSlugChange(selectedPosts, pattern);
                }
            }
        });

        // Individual button handlers
        document.querySelectorAll(".change-template-btn").forEach((btn) => {
            btn.addEventListener("click", async (e) => {
                const button = e.currentTarget as HTMLButtonElement;
                const pageId = button.dataset.pageId;
                const templatePath = button.dataset.templatePath;

                if (pageId && templatePath && window.openTemplateModal) {
                    const newTemplatePath = await window.openTemplateModal(
                        pageId,
                        templatePath,
                    );
                    if (newTemplatePath) {
                        await handleTemplateChange([pageId], newTemplatePath);
                    }
                }
            });
        });

        document.querySelectorAll(".change-slug-btn").forEach((btn) => {
            btn.addEventListener("click", async (e) => {
                const button = e.currentTarget as HTMLButtonElement;
                const pageId = button.dataset.pageId;
                const currentUrl = button.dataset.currentUrl;

                if (!pageId || !currentUrl) {
                    console.error("Missing required data attributes");
                    return;
                }

                if (window.openSlugModal) {
                    try {
                        const pattern = await window.openSlugModal(
                            [{ pageId, currentUrl }],
                            blogInfo
                        );
                        if (pattern) {
                            await handleSlugChange(
                                [{ pageId, currentUrl }],
                                pattern,
                            );
                        }
                    } catch (error) {
                        console.error("Error in slug change process:", error);
                        alert(
                            "Failed to change slug: " +
                                (error instanceof Error
                                    ? error.message
                                    : "Unknown error"),
                        );
                    }
                }
            });
        });


        // Initialize button states
        updateButtonStates();

        // Restore button handlers
        document.querySelectorAll(".restore-page-btn").forEach((btn) => {
            btn.addEventListener("click", async (e) => {
                const button = e.currentTarget as HTMLButtonElement;
                const pageId = button.dataset.pageId;
                if (pageId) {
                    await handleRestorePage(pageId);
                }
            });
        });

        function updateChangeSelectedButtons() {
            const anyChecked = Array.from(postCheckboxes).some(
                (cb) => cb.checked,
            );

            if (changeSelectedSlugsBtn) {
                changeSelectedSlugsBtn.disabled = !anyChecked;
            }
            if (changeSelectedTagsBtn) {
                changeSelectedTagsBtn.disabled = !anyChecked;
            }
        }

        // Handle Edit Tags
        const tagsModal = document.getElementById("tagsModal");
        const tagsContainer = document.getElementById("tagsContainer");
        const saveTagsBtn = document.getElementById("saveTagsBtn");
        let currentPostId = null;

        document.querySelectorAll(".edit-tags-btn").forEach((btn) => {
            btn.addEventListener("click", async (e) => {
                const target = e.currentTarget;
                currentPostId = target.dataset.postId || null;
                const currentTags =
                    target.dataset.postTags?.split(",").filter(Boolean) || [];

                if (!currentPostId) return;

                // Populate modal with all available tags
                if (tagsContainer) {
                    tagsContainer.innerHTML = Array.from(tagsMap.values())
                        .sort((a, b) => a.name.localeCompare(b.name))
                        .map(
                            (tag) => `
                            <label class="flex items-center space-x-2 cursor-pointer">
                                <input
                                    type="checkbox"
                                    class="tag-checkbox custom-checkbox"
                                    value="${tag.id}"
                                    ${currentTags.includes(tag.id) ? "checked" : ""}
                                >
                                <span class="text-sm">${tag.name}</span>
                            </label>
                        `,
                        )
                        .join("");
                }

                tagsModal.showModal();
            });
        });

        // Handle save tags
        saveTagsBtn?.addEventListener("click", async () => {
            if (!currentPostId) return;

            const selectedTags = Array.from(
                document.querySelectorAll(".tag-checkbox:checked"),
            ).map((cb) => cb.value);

            try {
                const response = await fetch("/api/blog-posts/update-tags", {
                    method: "POST",
                    headers: {
                        "Content-Type": "application/json",
                    },
                    body: JSON.stringify({
                        postId: currentPostId,
                        tagIds: selectedTags,
                    }),
                });

                if (!response.ok) {
                    throw new Error("Failed to update tags");
                }

                tagsModal.close();

                await updatePagesInCache([currentPostId], { tagIds: selectedTags });
                location.reload();
            } catch (error) {
                console.error("Error updating tags:", error);
                alert("Failed to update tags. Please try again.");
            }
        });

        // Handle modal close
        document.querySelectorAll(".close-modal-btn").forEach((btn) => {
            btn.addEventListener("click", () => {
                const modal = btn.closest("dialog");
                if (modal) {
                    modal.close();
                }
            });
        });

        // Add bulk tags handling
        const bulkTagsModal = document.getElementById("bulkTagsModal");
        const bulkTagsContainer = document.getElementById("bulkTagsContainer");
        const saveBulkTagsBtn = document.getElementById("saveBulkTagsBtn");
        const addTagsBtn = document.getElementById("addTagsBtn");
        const removeTagsBtn = document.getElementById("removeTagsBtn");
        let bulkTagMode = "add"; // or 'remove'

        document
            .getElementById("changeSelectedTagsBtn")
            ?.addEventListener("click", () => {
                const selectedPosts = Array.from(
                    document.querySelectorAll(".post-checkbox:checked"),
                ).map((cb) => ({
                    id: cb.dataset.postId,
                    tags:
                        cb
                            .closest(".post")
                            ?.querySelector(".edit-tags-btn")
                            ?.dataset.postTags?.split(",")
                            .filter(Boolean) || [],
                }));

                if (bulkTagsContainer) {
                    bulkTagsContainer.innerHTML = Array.from(tagsMap.values())
                        .sort((a, b) => a.name.localeCompare(b.name))
                        .map(
                            (tag) => `
                        <label class="flex items-center space-x-2 cursor-pointer">
                            <input
                                type="checkbox"
                                class="bulk-tag-checkbox custom-checkbox"
                                value="${tag.id}"
                            >
                            <span class="text-sm">${tag.name}</span>
                        </label>
                    `,
                        )
                        .join("");
                }

                bulkTagsModal.showModal();
            });

        // Handle add/remove mode toggle
        addTagsBtn?.addEventListener("click", () => {
            bulkTagMode = "add";
            addTagsBtn.classList.add("active");
            removeTagsBtn.classList.remove("active");
        });

        removeTagsBtn?.addEventListener("click", () => {
            bulkTagMode = "remove";
            removeTagsBtn.classList.add("active");
            addTagsBtn.classList.remove("active");
        });

        // Handle bulk save
        saveBulkTagsBtn?.addEventListener("click", async () => {
            const selectedPosts = Array.from(
                document.querySelectorAll(".post-checkbox:checked"),
            ).map((cb) => ({
                id: cb.dataset.postId,
                currentTags:
                    cb
                        .closest(".post")
                        ?.querySelector(".edit-tags-btn")
                        ?.dataset.postTags?.split(",")
                        .filter(Boolean) || [],
            }));

            const selectedTags = Array.from(
                document.querySelectorAll(".bulk-tag-checkbox:checked"),
            ).map((cb) => cb.value);

            try {
                const results = await Promise.allSettled(
                    selectedPosts.map(async (post) => {
                        let newTags;
                        if (bulkTagMode === "add") {
                            // Add selected tags if they don't exist
                            newTags = [
                                ...new Set([
                                    ...post.currentTags,
                                    ...selectedTags,
                                ]),
                            ];
                        } else {
                            // Remove selected tags if they exist
                            newTags = post.currentTags.filter(
                                (tag) => !selectedTags.includes(tag),
                            );
                        }

                        const response = await fetch(
                            "/api/blog-posts/update-tags",
                            {
                                method: "POST",
                                headers: {
                                    "Content-Type": "application/json",
                                },
                                body: JSON.stringify({
                                    postId: post.id,
                                    tagIds: newTags,
                                }),
                            },
                        );

                        if (!response.ok) {
                            throw new Error(
                                `Failed to update tags for post ${post.id}`,
                            );
                        }

                        return response.json();
                    }),
                );

                const successful = results.filter(
                    (result) => result.status === "fulfilled",
                ).length;
                const failed = results.filter(
                    (result) => result.status === "rejected",
                ).length;

                if (failed === 0) {
                    console.log(
                        `Successfully updated tags for all ${successful} posts!`,
                    );
                } else {
                    console.log(
                        `Updated tags for ${successful} posts. Failed to update ${failed} posts.`,
                    );
                }

                bulkTagsModal.close();

                await Promise.all(selectedPosts.map(post =>
                    updatePagesInCache([post.id], { tagIds: newTags })
                ));
                location.reload();
            } catch (error) {
                console.error("Error updating tags:", error);
                alert("Failed to update tags. Please try again.");
            }
        });

        // Add new tag functionality for single edit
        const newTagInput = document.getElementById("newTagInput");
        const addNewTagBtn = document.getElementById("addNewTagBtn");
        const newTagError = document.getElementById("newTagError");

        async function createNewTag(name) {
            const response = await fetch("/api/blog-posts/create-tag", {
                method: "POST",
                headers: {
                    "Content-Type": "application/json",
                },
                body: JSON.stringify({ name }),
            });

            if (!response.ok) {
                const error = await response.json();
                throw new Error(error.message || "Failed to create tag");
            }

            return response.json();
        }

        addNewTagBtn?.addEventListener("click", async () => {
            const name = newTagInput.value.trim();
            if (!name) {
                newTagError.textContent = "Tag name is required";
                newTagError.classList.remove("hidden");
                return;
            }

            try {
                newTagError.classList.add("hidden");
                const newTag = await createNewTag(name);

                // Add new checkbox to the list
                const newLabel = document.createElement("label");
                newLabel.className =
                    "flex items-center space-x-2 cursor-pointer";
                newLabel.innerHTML = `
                    <input
                        type="checkbox"
                        class="tag-checkbox custom-checkbox"
                        value="${newTag.id}"
                        checked
                    >
                    <span class="text-sm">${newTag.name}</span>
                `;
                tagsContainer.insertBefore(newLabel, tagsContainer.firstChild);

                // Clear input
                newTagInput.value = "";
            } catch (error) {
                newTagError.textContent = error.message;
                newTagError.classList.remove("hidden");
            }
        });

        // Add new tag functionality for bulk edit
        const newBulkTagSection = document.getElementById("newBulkTagSection");
        const newBulkTagInput = document.getElementById("newBulkTagInput");
        const addNewBulkTagBtn = document.getElementById("addNewBulkTagBtn");
        const newBulkTagError = document.getElementById("newBulkTagError");

        // Show/hide new tag section based on mode
        addTagsBtn?.addEventListener("click", () => {
            bulkTagMode = "add";
            addTagsBtn.classList.add("active");
            removeTagsBtn.classList.remove("active");
            newBulkTagSection.classList.remove("hidden");
        });

        removeTagsBtn?.addEventListener("click", () => {
            bulkTagMode = "remove";
            removeTagsBtn.classList.add("active");
            addTagsBtn.classList.remove("active");
            newBulkTagSection.classList.add("hidden");
        });

        addNewBulkTagBtn?.addEventListener("click", async () => {
            const name = newBulkTagInput.value.trim();
            if (!name) {
                newBulkTagError.textContent = "Tag name is required";
                newBulkTagError.classList.remove("hidden");
                return;
            }

            try {
                newBulkTagError.classList.add("hidden");
                const newTag = await createNewTag(name);

                // Add new checkbox to the list
                const newLabel = document.createElement("label");
                newLabel.className =
                    "flex items-center space-x-2 cursor-pointer";
                newLabel.innerHTML = `
                    <input
                        type="checkbox"
                        class="bulk-tag-checkbox custom-checkbox"
                        value="${newTag.id}"
                        checked
                    >
                    <span class="text-sm">${newTag.name}</span>
                `;
                bulkTagsContainer.insertBefore(
                    newLabel,
                    bulkTagsContainer.firstChild,
                );

                // Clear input
                newBulkTagInput.value = "";
            } catch (error) {
                newBulkTagError.textContent = error.message;
                newBulkTagError.classList.remove("hidden");
            }
        });
    });


    async function updatePagesInCache(pageIds: string[], updates: Partial<HubSpotBlogPost>) {
        try {
            const accessToken = document.querySelector('meta[name="access-token"]')?.getAttribute('content');
            if (!accessToken) return;

            const isArchived = new URLSearchParams(window.location.search).has('archived');

            console.log('Sending cache update request:', {
                type: CacheType.BLOGS,
                pageIds,
                updates,
                options: { archived: isArchived }
            });

            const response = await fetch('/api/cache/update', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({
                    type: CacheType.BLOGS,
                    pageIds,
                    updates,
                    options: { archived: isArchived }
                })
            });

            if (!response.ok) {
                const error = await response.json();
                throw new Error(error.message || 'Failed to update cache');
            }

            const result = await response.json();
            console.log('Cache update response:', result);
        } catch (error) {
            console.error('Failed to update cache:', error);
        }
    }
</script>
